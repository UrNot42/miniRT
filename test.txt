Starting All tests \/
>Starting Tuple tests \/
Scenario: A tuple with w=1.0 is a point
  Given a ← tuple(4.3, -4.2, 3.1, 1.0)
  Then a.x = 4.3: Passed [OK]
    And a.y = -4.2: Passed [OK]
    And a.z = 3.1: Passed [OK]
    And a.w = 1.0: Passed [OK]
    And a is point: Passed [OK]
    And a is not vector: Passed [OK]
=> Validated Scenario

Scenario: point() creates tuples with w=1
  Given p ← point(4, -4, 3)
  Then p = tuple(4, -4, 3, 1): Passed [OK]
=> Validated Scenario

Scenario: vector() creates tuples with w=0
  Given v ← vector(4, -4, 3)
  Then v = tuple(4, -4, 3, 0): Passed [OK]
=> Validated Scenario

Scenario: Adding two tuples
  Given a1 ← tuple(3, -2, 5, 1)
    And a2 ← tuple(-2, 3, 1, 0)
  Then a1 + a2 = tuple(1, 1, 6, 1): Passed [OK]
=> Validated Scenario

Scenario: Subtracting two points
  Given p1 ← point(3, 2, 1)
    And p2 ← point(5, 6, 7)
  Then p1 - p2 = vector(-2, -4, -6): Passed [OK]
=> Validated Scenario

Scenario: Subtracting a vector from a point
  Given p ← point(3, 2, 1)
    And v ← vector(5, 6, 7)
  Then p - v = point(-2, -4, -6): Passed [OK]
=> Validated Scenario

Scenario: Subtracting two vectors
  Given v1 ← vector(3, 2, 1)
    And v2 ← vector(5, 6, 7)
  Then v1 - v2 = vector(-2, -4, -6): Passed [OK]
=> Validated Scenario

Scenario: Subtracting a vector from the zero vector
  Given zero ← vector(0, 0, 0)
  Given v ← vector(1, -2, 3)
  Then zero - v = vector(-1, 2, -3): Passed [OK]
=> Validated Scenario

Scenario: Negating a tuple
  Given a ← tuple(1, -2, 3, -4)
  Then -a = tuple(-1, 2, -3, 4): Passed [OK]
=> Validated Scenario

Scenario: Multiplying a tuple by a scalar
  Given a ← tuple(1, -2, 3, -4)
  Then a * 3.5 = tuple(3.5, -7, 10.5, -14): Passed [OK]
=> Validated Scenario

Scenario: Multiplying a tuple by a fraction
  Given a ← tuple(1, -2, 3, -4)
  Then a * 0.5 = tuple(0.5, -1, 1.5, -2): Passed [OK]
=> Validated Scenario

Scenario: Dividing a tuple by a scalar
  Given a ← tuple(1, -2, 3, -4)
  Then a / 2 = tuple(0.5, -1, 1.5, -2): Passed [OK]
=> Validated Scenario

==> Finished Tuple tests [OK]
##################

>Starting Vector tests \/
Scenario: Computing the magnitude of vector(1, 0, 0)
  Given v ← vector(1, 0, 0)
  Then magnitude(v) = 1: Passed [OK]
=> Validated Scenario

Scenario: Computing the magnitude of vector(0, 1, 0)
  Given v ← vector(0, 1, 0)
  Then magnitude(v) = 1: Passed [OK]
=> Validated Scenario

Scenario: Computing the magnitude of vector(0, 0, 1)
  Given v ← vector(0, 0, 1)
  Then magnitude(v) = 1: Passed [OK]
=> Validated Scenario

Scenario: Computing the magnitude of vector(1, 2, 3)
  Given v ← vector(1, 2, 3)
  Then magnitude(v) = √14: Passed [OK]
=> Validated Scenario

Scenario: Computing the magnitude of vector(-1, -2, -3)
  Given v ← vector(-1, -2, -3)
  Then magnitude(v) = √14: Passed [OK]
=> Validated Scenario

Scenario: Normalizing vector(4, 0, 0) gives (1, 0, 0)
  Given v ← vector(4, 0, 0)
  Then normalize(v) = vector(1, 0, 0): Passed [OK]
=> Validated Scenario

Scenario: Normalizing vector(1, 2, 3)
  Given v ← vector(1, 2, 3)
  Then normalize(v) = approximately vector(0.26726, 0.53452, 0.80178): Passed [OK]
=> Validated Scenario

Scenario: The magnitude of a normalized vector
  Given v ← vector(1, 2, 3)
  Then magnitude(norm) = 1: Passed [OK]
=> Validated Scenario

Scenario: The dot product of two tuples
  Given a ← vector(1, 2, 3)
    And b ← vector(2, 3, 4)
  Then dot(a, b) = 20: Passed [OK]
=> Validated Scenario

Scenario: The cross product of two vectors
  Given a ← vector(1, 2, 3)
  Given b ← vector(2, 3, 4)
  Then cross(a, b) = vector(-1, 2, -1): Passed [OK]
  Then cross(b, a) = vector(1, -2, 1): Passed [OK]
=> Validated Scenario

==> Finished Vector tests [OK]
##################

>Starting Color tests \/
Scenario: Colors are (red, green, blue) tuples
  Given c ← color(-0.5, 0.4, 1.7)
  Then c.red = -0.5: Passed [OK]
    And c.green = 0.4: Passed [OK]
    And c.blue = 1.7: Passed [OK]
=> Validated Scenario

Scenario: Adding colors
  Given c1 ← color(0.9, 0.6, 0.75)
  Given c2 ← color(0.7, 0.1, 0.25)
  Then c1 + c2 = color(1.6, 0.7, 1.0): Passed [OK]
=> Validated Scenario

Scenario: Subtracting colors
  Given c1 ← color(0.9, 0.6, 0.75)
  Given c2 ← color(0.7, 0.1, 0.25)
  Then c1 - c2 = color(0.2, 0.5, 0.5): Passed [OK]
=> Validated Scenario

Scenario: Multiplying a color by a scalar
  Given c ← color(0.2, 0.3, 0.4)
  Then c * 2 = color(0.4, 0.6, 0.8): Passed [OK]
=> Validated Scenario

Scenario: Multiplying colors
  Given c1 ← color(1, 0.2, 0.4)
  Given c2 ← color(0.9, 1, 0.1)
  Then c1 * c2 = color(0.9, 0.2, 0.04): Passed [OK]
=> Validated Scenario

==> Finished Color tests [OK]
##################

>Starting Canvas tests \/
Scenario: Creating a canvas
  Given c ← canvas(10, 20)
  Then c.width = 10: Passed [OK]
    And c.height = 20: Passed [OK]
    And every pixel of c is color(0, 0, 0): Passed [OK]
=> Validated Scenario

Scenario: Writing pixels to a canvas
  Given c ← canvas(10, 20)
  Given red ← color(1, 0, 0)
  Then pixel_at(c, 2, 3) = red: Passed [OK]
=> Validated Scenario

==> Finished Canvas tests [OK]
##################

>Starting Matrix tests \/
Scenario: Constructing and inspecting a 4x4 matrix
  Given the following 4x4 matrix M:
 |  1   |  2   |  3   |  4   |
 |  5.5 |  6.5 |  7.5 |  8.5 |
 |  9   |  10  |  11  |  12  |
 |  13.5|  14.5|  15.5|  16.5|
  Then M[0,0] = 1: Passed [OK]
    And M[0,3] = 4: Passed [OK]
    And M[1,0] = 5.5: Passed [OK]
    And M[1,2] = 7.5: Passed [OK]
    And M[2,2] = 11: Passed [OK]
    And M[3,0] = 13.5: Passed [OK]
    And M[3,2] = 15.5: Passed [OK]
=> Validated Scenario

Scenario: A 2x2 matrix ought to be representable
  Given the following 2x2 matrix M:
 | -3 |  5 |
 |  1 | -2 |
  Then M[0,0] = -3: Passed [OK]
    And M[0,1] = 5: Passed [OK]
    And M[1,0] = 1: Passed [OK]
    And M[1,1] = -2: Passed [OK]
=> Validated Scenario

Scenario: A 3x3 matrix ought to be representable
  Given the following 3x3 matrix M:
 | -3 |  5 |  0 |
 |  1 | -2 |  7 |
 |  0 |  1 |  1 |
  Then M[0,0] = -3: Passed [OK]
    And M[1,1] = -2: Passed [OK]
    And M[2,2] = 1: Passed [OK]
=> Validated Scenario

Scenario: Matrix equality with identical matrices
  Given the following matrix A:
 | 1 | 2 | 3 | 4 |
 | 5 | 6 | 7 | 8 |
 | 9 | 8 | 7 | 6 |
 | 5 | 4 | 3 | 2 |
    And the following matrix B:
 | 1 | 2 | 3 | 4 |
 | 5 | 6 | 7 | 8 |
 | 9 | 8 | 7 | 6 |
 | 5 | 4 | 3 | 2 |
  Then A = B: Passed [OK]
=> Validated Scenario

Scenario: Matrix equality with different matrices
    And the following matrix A:
 | 1 | 2 | 3 | 4 |
 | 5 | 6 | 7 | 8 |
 | 9 | 8 | 7 | 6 |
 | 5 | 4 | 3 | 2 |
    And the following matrix B:
 | 2 | 3 | 4 | 5 |
 | 6 | 7 | 8 | 9 |
 | 8 | 7 | 6 | 5 |
 | 4 | 3 | 2 | 1 |
  Then A != B: Passed [OK]
=> Validated Scenario

Scenario: Multiplying two matrices
  Given the following matrix A:
 | 1 | 2 | 3 | 4 |
 | 5 | 6 | 7 | 8 |
 | 9 | 8 | 7 | 6 |
 | 5 | 4 | 3 | 2 |
    And And the following matrix B:
 |-2 | 1 | 2 | 3 |
 | 3 | 2 | 1 |-1 |
 | 4 | 3 | 6 | 5 |
 | 1 | 2 | 7 | 8 |
  Then A * B is the following 4x4 matrix:
 |  20 |  22 |  50 |  48 |
 |  44 |  54 | 114 | 108 |
 |  40 |  58 | 110 | 102 |
 |  16 |  26 |  46 |  42 |: Passed [OK]
=> Validated Scenario

Scenario: A matrix multiplied by a tuple
  Given the following matrix A:
 | 1 | 2 | 3 | 4 |
 | 2 | 4 | 4 | 2 |
 | 8 | 6 | 4 | 1 |
 | 0 | 0 | 0 | 1 |
  Given b ← tuple(1, 2, 3, 1)
  Then A * b = tuple(18, 24, 33, 1): Passed [OK]
=> Validated Scenario

Scenario: Multiplying a matrix by the identity matrix
  Given the following matrix A:
 | 0 | 1 | 2 | 4 |
 | 1 | 2 | 4 | 8 |
 | 2 | 4 | 8 | 16|
 | 4 | 8 | 16| 32|
  Then A * identity_matrix = A: Passed [OK]
=> Validated Scenario

Scenario: Multiplying the identity matrix by a tuple
  Given a ← tuple(1, 2, 3, 4)
  Then identity_matrix * a = a: Passed [OK]
=> Validated Scenario

Scenario: Transposing a matrix
  Given the following matrix A:
 | 0 | 9 | 3 | 0 |
 | 9 | 8 | 0 | 8 |
 | 1 | 8 | 5 | 3 |
 | 0 | 0 | 5 | 8 |
  Then transpose(A) is the following matrix:
 | 0 | 9 | 1 | 0 |
 | 9 | 8 | 8 | 0 |
 | 3 | 0 | 5 | 5 |
 | 0 | 8 | 3 | 8 |: Passed [OK]
=> Validated Scenario

Scenario: Transposing the identity matrix
  Given A ← transpose(identity_matrix)
  Then A = identity_matrix: Passed [OK]
=> Validated Scenario

Scenario: Calculating the determinant of a 2x2 matrix
  Given the following 2x2 matrix A:
 | 1 | 5 |
 |-3 | 2 |
  Then determinant(A) = 17: Passed [OK]
=> Validated Scenario

Scenario: Submatrix of a 3x3 matrix is a 2x2 matrix
  Given the following 3x3 matrix A:
 | 1 | 5 | 0 |
 |-3 | 2 | 7 |
 | 0 | 6 |-3 |
  Then submatrix(A, 0, 2) is the following 2x2 matrix:
 |-3 | 2 |
 | 0 | 6 |: Passed [OK]
=> Validated Scenario

Scenario: Submatrix of a 4x4 matrix is a 3x3 matrix
  Given the following 4x4 matrix A:
 |-6 | 1 | 1 | 6 |
 |-8 | 5 | 8 | 6 |
 |-1 | 0 | 8 | 2 |
 |-7 | 1 |-1 | 1 |
  Then submatrix(A, 2, 1) is the following 3x3 matrix:
 |-6 | 1 | 6 |
 |-8 | 8 | 6 |
 |-7 |-1 | 1 |: Passed [OK]
=> Validated Scenario

Scenario: Calculating a minor of a 3x3 matrix
  Given the following 3x3 matrix A:
 | 3 |  5 |  0 |
 | 2 | -1 | -7 |
 | 6 | -1 |  5 |
  Then determinant(B) = 25: Passed [OK]
    And minor(A, 1, 0) = 25: Passed [OK]
=> Validated Scenario

Scenario: Calculating a cofactor of a 3x3 matrix
  Given the following 3x3 matrix A:
 | 3 |  5 |  0 |
 | 2 | -1 | -7 |
 | 6 | -1 |  5 |
  Then minor(A, 0, 0) = -12: Passed [OK]
    And cofactor(A, 0, 0) = -12: Passed [OK]
    And minor(A, 1, 0) = 25: Passed [OK]
    And cofactor(A, 1, 0) = -25: Passed [OK]
=> Validated Scenario

Scenario: Calculating the determinant of a 3x3 matrix
  Given the following 3x3 matrix A:
 |  1 | 2 |  6 |
 | -5 | 8 | -4 |
 |  2 | 6 |  4 |
  Then cofactor(A, 0, 0) = 56: Passed [OK]
    And cofactor(A, 0, 1) = 12: Passed [OK]
    And cofactor(A, 0, 2) = -46: Passed [OK]
    And determinant(A) = -196: Passed [OK]
=> Validated Scenario

Scenario: Calculating the determinant of a 4x4 matrix
  Given the following 4x4 matrix A:
 | -2 | -8 |  3 |  5 |
 | -3 |  1 |  7 |  3 |
 |  1 |  2 | -9 |  6 |
 | -6 |  7 |  7 | -9 |
  Then cofactor(A, 0, 0) = 690: Passed [OK]
    And cofactor(A, 0, 1) = 447: Passed [OK]
    And cofactor(A, 0, 2) = 210: Passed [OK]
    And cofactor(A, 0, 3) = 51: Passed [OK]
    And determinant(A) = -4071: Passed [OK]
=> Validated Scenario

Scenario: Testing an invertible matrix for invertibility
  Given the following 4x4 matrix A:
 | 6 | 4 | 4 | 4 |
 | 5 | 5 | 7 | 6 |
 | 4 |-9 | 3 |-7 |
 | 9 | 1 | 7 |-6 |
  Then determinant(A) = -2120: Passed [OK]
    And A is invertible: Passed [OK]
=> Validated Scenario

Scenario: Testing a noninvertible matrix for invertibility
  Given the following 4x4 matrix A:
 |-4 | 2 |-2 |-3 |
 | 9 | 6 | 2 | 6 |
 | 0 |-5 | 1 |-5 |
 | 0 | 0 | 0 | 0 |
  Then determinant(A) = 0: Passed [OK]
    And A is not invertible: Passed [OK]
=> Validated Scenario

Scenario: Calculating the inverse of a matrix
  Given the following 4x4 matrix A:
 | -5 |  2 |  6 | -8 |
 |  1 | -5 |  1 |  8 |
 |  7 |  7 | -6 | -7 |
 |  1 | -3 |  7 |  4 |
  Then determinant(A) = 532: Passed [OK]
    And cofactor(A, 2, 3) = -160: Passed [OK]
    And B[3,2] = -160/532: Passed [OK]
    And cofactor(A, 3, 2) = 105: Passed [OK]
    And B[2,3] = 105/532: Passed [OK]
    And B is the following 4x4 matrix:
 |  0.21805 |  0.45113 |  0.24060 | -0.04511 |
 | -0.80827 | -1.45677 | -0.44361 |  0.52068 |
 | -0.07895 | -0.22368 | -0.05263 |  0.19737 |
 | -0.52256 | -0.81391 | -0.30075 |  0.30639 |: Passed [OK]
=> Validated Scenario

Scenario: Calculating the inverse of another matrix
  Given the following 4x4 matrix A:
 |  8 | -5 |  9 |  2 |
 |  7 |  5 |  6 |  1 |
 | -6 |  0 |  9 |  6 |
 | -3 |  0 | -9 | -4 |
  Then inverse(A) is the following 4x4 matrix:
 | -0.15385 | -0.15385 | -0.28205 | -0.53846 |
 | -0.07692 |  0.12308 |  0.02564 |  0.03077 |
 | 0.35897  |  0.35897 |  0.43590 |  0.92308 |
 | -0.69231 | -0.69231 | -0.76923 | -1.92308 |: Passed [OK]
=> Validated Scenario

Scenario: Calculating the inverse of a third matrix
  Given the following 4x4 matrix A:
 |  9 |  3 |  0 |  9 |
 | -5 | -2 | -6 | -3 |
 | -4 |  9 |  6 |  4 |
 | -7 |  6 |  6 |  2 |
  Then inverse(A) is the following 4x4 matrix:
 | -0.04074 | -0.07778 |  0.14444 | -0.22222 |
 | -0.07778 |  0.03333 |  0.36667 | -0.33333 |
 | -0.02901 | -0.14630 | -0.10926 |  0.12963 |
 |  0.17778 |  0.06667 | -0.26667 |  0.33333 |: Passed [OK]
=> Validated Scenario

Scenario: Multiplying a product by its inverse
  Given the following 4x4 matrix A:
 |  3 | -9 |  7 |  3 |
 |  3 | -8 |  2 | -9 |
 | -4 |  4 |  4 |  1 |
 | -6 |  5 | -1 |  1 |
  Given the following 4x4 matrix B:
 |  8 |  2 |  2 |  2 |
 |  3 | -1 |  7 |  0 |
 |  7 |  0 |  5 |  4 |
 |  6 | -2 |  0 |  5 |
  Given C ← A * B
  Then C * inverse(B) = A: Passed [OK]
=> Validated Scenario

Scenario: Inverting the identity matrix
  Given the following 4x4 identity matrix I:
 | 1 | 0 | 0 | 0 |
 | 0 | 1 | 0 | 0 |
 | 0 | 0 | 1 | 0 |
 | 0 | 0 | 0 | 1 |
  When I ← inverse(I)
  Then I is the following 4x4 identity matrix:
 | 1 | 0 | 0 | 0 |
 | 0 | 1 | 0 | 0 |
 | 0 | 0 | 1 | 0 |
 | 0 | 0 | 0 | 1 |: Passed [OK]
=> Validated Scenario

Scenario: Multiplying a matrix by its inverse
  Given the following 4x4 matrix A:
 |  3 | -9 |  7 |  3 |
 |  3 | -8 |  2 | -9 |
 | -4 |  4 |  4 |  1 |
 | -6 |  5 | -1 |  1 |
  Given B ← A * inverse(A)
  Then B is the 4x4 identity matrix:
 | 1 | 0 | 0 | 0 |
 | 0 | 1 | 0 | 0 |
 | 0 | 0 | 1 | 0 |
 | 0 | 0 | 0 | 1 |: Passed [OK]
=> Validated Scenario

==> Finished Matrix tests [OK]
##################

>Starting Matrix tests \/
Scenario: Multiplying by a translation matrix
  Given transform ← translation(5, -3, 2)
    And p ← point(-3, 4, 5)
  Then transform * p = point(2, 1, 7): Passed [OK]
=> Validated Scenario

Scenario: Multiplying by the inverse of a translation matrix
  Given transform ← translation(5, -3, 2)
    And inv ← inverse(transform)
    And p ← point(-3, 4, 5)
  Then inv * p = point(-8, 7, 3): Passed [OK]
=> Validated Scenario

Scenario: Translation does not affect vectors
  Given transform ← translation(5, -3, 2)
    And v ← vector(-3, 4, 5)
  Then transform * v = v: Passed [OK]
=> Validated Scenario

Scenario: A scaling matrix applied to a point
  Given transform ← scaling(2, 3, 4)
    And p ← point(-4, 6, 8)
  Then transform * p = point(-8, 18, 32): Passed [OK]
=> Validated Scenario

Scenario: A scaling matrix applied to a vector
  Given transform ← scaling(2, 3, 4)
    And v ← vector(-4, 6, 8)
  Then transform * v = vector(-8, 18, 32): Passed [OK]
=> Validated Scenario

Scenario: Multiplying by the inverse of a scaling matrix
  Given transform ← scaling(2, 3, 4)
    And inv ← inverse(transform)
    And v ← vector(-4, 6, 8)
  Then inv * v = vector(-2, 2, 2): Passed [OK]
=> Validated Scenario

Scenario: Reflection is scaling by a negative value
  Given transform ← scaling(-1, 1, 1)
    And p ← point(2, 3, 4)
  Then transform * p = point(-2, 3, 4): Passed [OK]
=> Validated Scenario

Scenario: Rotating a point around the x axis
  Given p ← point(0, 1, 0)
    And half_quarter ← rotation_x(π / 4)
    And full_quarter ← rotation_x(π / 2)
  Then half_quarter * p = point(0, √2/2, √2/2): Passed [OK]
    And full_quarter * p = point(0, 0, 1): Passed [OK]
=> Validated Scenario

Scenario: The inverse of an x-rotation rotates in the opposite direction
  Given p ← point(0, 1, 0)
    And half_quarter ← rotation_x(π / 4)
    And inv ← inverse(half_quarter)
  Then inv * p = point(0, √2/2, -√2/2): Passed [OK]
=> Validated Scenario

Scenario: Rotating a point around the y axis
  Given p ← point(0, 0, 1)
    And half_quarter ← rotation_y(π / 4)
    And full_quarter ← rotation_y(π / 2)
  Then half_quarter * p = point(√2/2, 0, √2/2): Passed [OK]
    And full_quarter * p = point(1, 0, 0): Passed [OK]
=> Validated Scenario

Scenario: Rotating a point around the z axis
  Given p ← point(0, 1, 0)
    And half_quarter ← rotation_z(π / 4)
    And full_quarter ← rotation_z(π / 2)
  Then half_quarter * p = point(-√2/2, √2/2, 0): Passed [OK]
    And full_quarter * p = point(-1, 0, 0): Passed [OK]
=> Validated Scenario

Scenario: A shearing transformation moves x in proportion to y
  Given transform ← shearing(1, 0, 0, 0, 0, 0)
    And p ← point(2, 3, 4)
  Then transform * p = point(5, 3, 4): Passed [OK]
=> Validated Scenario

Scenario: A shearing transformation moves x in proportion to z
  Given transform ← shearing(0, 1, 0, 0, 0, 0)
    And p ← point(2, 3, 4)
  Then transform * p = point(6, 3, 4): Passed [OK]
=> Validated Scenario

Scenario: A shearing transformation moves y in proportion to x
  Given transform ← shearing(0, 0, 1, 0, 0, 0)
    And p ← point(2, 3, 4)
  Then transform * p = point(2, 5, 4): Passed [OK]
=> Validated Scenario

Scenario: A shearing transformation moves y in proportion to z
  Given transform ← shearing(0, 0, 0, 1, 0, 0)
    And p ← point(2, 3, 4)
  Then transform * p = point(2, 7, 4): Passed [OK]
=> Validated Scenario

Scenario: A shearing transformation moves z in proportion to x
  Given transform ← shearing(0, 0, 0, 0, 1, 0)
    And p ← point(2, 3, 4)
  Then transform * p = point(2, 3, 6): Passed [OK]
=> Validated Scenario

Scenario: A shearing transformation moves z in proportion to y
  Given transform ← shearing(0, 0, 0, 0, 0, 1)
    And p ← point(2, 3, 4)
  Then transform * p = point(2, 3, 7): Passed [OK]
=> Validated Scenario

Scenario: Individual transformations are applied in sequence
  Given p ← point(1, 0, 1)
    And A ← rotation_x(π / 2)
    And B ← scaling(5, 5, 5)
    And C ← translation(10, 5, 7)
  When p2 ← A * p
  Then p2 = point(1, -1, 0): Passed [OK]
  When p3 ← B * p2
  Then p3 = point(5, -5, 0): Passed [OK]
  When p4 ← C * p3
  Then p4 = point(15, 0, 7): Passed [OK]
=> Validated Scenario

Scenario: Chained transformations must be applied in reverse order
  Given p ← point(1, 0, 1)
    And A ← rotation_x(π / 2)
    And B ← scaling(5, 5, 5)
    And C ← translation(10, 5, 7)
  When T ← C * B * A
  Then T * p = point(15, 0, 7): Passed [OK]
=> Validated Scenario

==> Finished Matrix Transform tests [OK]
##################

>Starting Rays tests \/
Scenario: Creating and querying a ray
  Given origin ← point(1, 2, 3)
    And direction ← vector(4, 5, 6)
  When r ← ray(origin, direction)
  Then r.origin = origin: Passed [OK]
    And r.direction = direction: Passed [OK]
=> Validated Scenario

Scenario: Computing a point from a distance
  Given r ← ray(point(2, 3, 4), vector(1, 0, 0))
  Then position(r, 0) = point(2, 3, 4): Passed [OK]
    And position(r, 1) = point(3, 3, 4): Passed [OK]
    And position(r, -1) = point(1, 3, 4): Passed [OK]
    And position(r, 2.5) = point(4.5, 3, 4): Passed [OK]
=> Validated Scenario

Scenario: A ray intersects a sphere at two points
  Given r ← ray(point(0, 0, -5), vector(0, 0, 1))
    And s ← sphere()
  When xs ← intersect(s, r)
  Then xs.count = 2: Passed [OK]
    And xs[0] = 4.0: Passed [OK]
    And xs[1] = 6.0: Passed [OK]
=> Validated Scenario

Scenario: A ray intersects a sphere at a tangent
  Given r ← ray(point(0, 1, -5), vector(0, 0, 1))
    And s ← sphere()
  When xs ← intersect(s, r)
  Then xs.count = 2: Passed [OK]
    And xs[0] = 4.0: Passed [OK]
    And xs[1] = 6.0: Passed [OK]
=> Validated Scenario

Scenario: A ray misses a sphere
  Given r ← ray(point(0, 2, -5), vector(0, 0, 1))
    And s ← sphere()
  When xs ← intersect(s, r)
  Then xs.count = 0: Passed [OK]
=> Validated Scenario

Scenario: A ray originates inside a sphere
  Given r ← ray(point(0, 0, 0), vector(0, 0, 1))
    And s ← sphere()
  When xs ← intersect(s, r)
  Then xs.count = 2: Passed [OK]
    And xs[0] = 4.0: Passed [OK]
    And xs[1] = 6.0: Passed [OK]
=> Validated Scenario

Scenario: A sphere is behind a ray
  Given r ← ray(point(0, 0, 5), vector(0, 0, 1))
    And s ← sphere()
  When xs ← intersect(s, r)
  Then xs.count = 2: Passed [OK]
    And xs[0] = 4.0: Passed [OK]
    And xs[1] = 6.0: Passed [OK]
=> Validated Scenario

Scenario: An intersection encapsulates t and object
  Given s ← sphere()
  When i ← intersection(3.5, s)
  Then i.t = 3.5: Passed [OK]
    And i.object = s: Passed [OK]
=> Validated Scenario

Scenario: Aggregating intersections
  Given s ← sphere()
  Given i ← intersection(1, s)
    And i ← intersection(2, s)
  When xs ← intersections(i1, i2)
  Then xs.count = 2: Passed [OK]
    And xs[0].t = 1: Passed [OK]
    And xs[1].t = 2: Passed [OK]
=> Validated Scenario

Scenario: Intersect sets the object on the intersection
  Given r ← ray(point(0, 0, -5), vector(0, 0, 1))
    And s ← sphere()
  When xs ← intersect(s, r)
  Then xs.count = 2: Passed [OK]
    And xs[0].object = 1: Passed [OK]
    And xs[1].object = 2: Passed [OK]
=> Validated Scenario

Scenario: The hit, when all intersections have positive t
  Given s ← sphere()
    And i1 ← intersection(1, s)
    And i2 ← intersection(2, s)
    And xs ← intersections(i2, i1)
  When i ← hit(xs)
  Then i = i1: Passed [OK]
=> Validated Scenario

Scenario: The hit, when some intersections have negative t
  Given s ← sphere()
    And i1 ← intersection(-1, s)
    And i2 ← intersection(1, s)
    And xs ← intersections(i2, i1)
  When i ← hit(xs)
  Then i = i2: Passed [OK]
=> Validated Scenario

Scenario: The hit, when all intersections have negative t
  Given s ← sphere()
    And i1 ← intersection(-2, s)
    And i2 ← intersection(-1, s)
    And xs ← intersections(i2, i1)
  When i ← hit(xs)
  Then i is nothing: Passed [OK]
=> Validated Scenario

Scenario: The hit is always the lowest nonnegative intersection
  Given s ← sphere()
    And i1 ← intersection(5, s)
    And i2 ← intersection(7, s)
    And i3 ← intersection(-3, s)
    And i4 ← intersection(2, s)
    And xs ← intersections(i1, i2, i3, i4)
  When i ← hit(xs)
  Then i = i4: Passed [OK]
=> Validated Scenario

Scenario: Translating a ray
  Given r ← ray(point(1, 2, 3), vector(0, 1, 0))
    And m ← translation(3, 4, 5)
  When r2 ← transform(r, m)
  Then r2.origin = point(4, 6, 8): Passed [OK]
    And r2.direction = vector(0, 1, 0): Passed [OK]
=> Validated Scenario

Scenario: Scaling a ray
  Given r ← ray(point(1, 2, 3), vector(0, 1, 0))
    And m ← scaling(2, 3, 4)
  When r2 ← transform(r, m)
  Then r2.origin = point(2, 6, 12): Passed [OK]
    And r2.direction = vector(0, 3, 0): Passed [OK]
=> Validated Scenario

Scenario: A sphere's default transformation
  Given s ← sphere()
  Then s.transform = identity_matrix: Passed [OK]
=> Validated Scenario

Scenario: Changing a sphere's transformation
  Given s ← sphere()
    And t ← translation(2, 3, 4)
  When set_transform(s, t)
  Then s.transform = t: Passed [OK]
=> Validated Scenario

Scenario: Intersecting a scaled sphere with a ray
  Given r ← ray(point(0, 0, -5), vector(0, 0, 1))
    And s ← sphere()
  When set_transform(s, scaling(2, 2, 2))
    And xs ← intersect(s, r)
  Then xs.count = 2: Passed [OK]
  Then xs[0].t = 3: Passed [OK]
  Then xs[1].t = 7: Passed [OK]
=> Validated Scenario

Scenario: Intersecting a translated sphere with a ray
  Given r ← ray(point(0, 0, -5), vector(0, 0, 1))
    And s ← sphere()
  When set_transform(s, translation(5, 0, 0))
    And xs ← intersect(s, r)
  Then xs.count = 0: Passed [OK]
=> Validated Scenario

==> Finished Rays tests [OK]
##################

>Starting Normal tests \/
Scenario: The normal on a sphere at a point on the x axis
  Given s ← sphere()
  When n ← normal_at(s, point(1, 0, 0))
  Then n = vector(1, 0, 0): Passed [OK]
=> Validated Scenario

Scenario: The normal on a sphere at a point on the y axis
  Given s ← sphere()
  When n ← normal_at(s, point(0, 1, 0))
  Then n = vector(0, 1, 0): Passed [OK]
=> Validated Scenario

Scenario: The normal on a sphere at a point on the z axis
  Given s ← sphere()
  When n ← normal_at(s, point(0, 0, 1))
  Then n = vector(0, 0, 1): Passed [OK]
=> Validated Scenario

Scenario: The normal on a sphere at a nonaxial point
  Given s ← sphere()
  When n ← normal_at(s, point(√3/3, √3/3, √3/3))
  Then n = vector(√3/3, √3/3, √3/3): Passed [OK]
=> Validated Scenario

Scenario: The normal is a normalized vector
  Given s ← sphere()
  When n ← normal_at(s, point(√3/3, √3/3, √3/3))
  Then n = normalize(n): Passed [OK]
=> Validated Scenario

Scenario: Computing the normal on a translated sphere
  Given s ← sphere()
    And set_transform(s, translation(0, 1, 0))
  When n ← normal_at(s, point(0, 1.70711, -0.70711))
  Then n = vector(0, 0.70711, -0.70711): Passed [OK]
=> Validated Scenario

Scenario: Computing the normal on a transformed sphere
  Given s ← sphere()
    And m ← scaling(1, 0.5, 1) * rotation_z(π/5)
    And set_transform(s, m)
  When n ← normal_at(s, point(0, √2/2, -√2/2))
  Then n = vector(0, 0.97014, -0.24254): Passed [OK]
=> Validated Scenario

Scenario: Reflecting a vector approaching at 45°
  Given v ← vector(1, -1, 0)
    And n ← vector(0, 1, 0)
  When r ← reflect(v, n)
  Then r = vector(1, 1, 0): Passed [OK]
=> Validated Scenario

Scenario: Reflecting a vector off a slanted surface
  Given v ← vector(0, -1, 0)
    And n ← vector(√2/2, √2/2, 0)
  When r ← reflect(v, n)
  Then r = vector(1, 0, 0): Passed [OK]
=> Validated Scenario

Scenario: The default material
  Given m ← material()
  Then m.color = color(1, 1, 1): Passed [OK]
    And m.ambient = 0.1: Passed [OK]
    And m.diffuse = 0.9: Passed [OK]
    And m.specular = 0.9: Passed [OK]
    And m.shininess = 200.0: Passed [OK]
=> Validated Scenario

Scenario: A sphere has a default material
  Given s ← sphere()
  When m ← s.material
  Then  m = material(): Passed [OK]
=> Validated Scenario

Scenario: A sphere may be assigned a material
  Given s ← sphere()
    And m ← material()
    And m.ambient ← 1
  When s.material ← m
  Then s.material = m: Passed [OK]
=> Validated Scenario

Scenario: Lighting with the eye between the light and the surface
  Given m ← material()
    And position ← point(0, 0, 0)
  Given eyev ← vector(0, 0, -1)
    And normalv ← vector(0, 0, -1)
    And light ← point_light(point(0, 0, -10), color(1, 1, 1))
  When result ← lighting(m, light, position, eyev, normalv)
  Then result = color(1.9, 1.9, 1.9): Passed [OK]
=> Validated Scenario

Scenario: Lighting with the eye between light and surface, eye offset 45°
  Given m ← material()
    And position ← point(0, 0, 0)
  Given eyev ← vector(0, √2/2, -√2/2)
    And normalv ← vector(0, 0, -1)
    And light ← point_light(point(0, 0, -10), color(1, 1, 1))
  When result ← lighting(m, light, position, eyev, normalv)
  Then result = color(1.0, 1.0, 1.0): Passed [OK]
=> Validated Scenario

Scenario: Lighting with eye opposite surface, light offset 45°
  Given m ← material()
    And position ← point(0, 0, 0)
  Given eyev ← vector(0, 0, -1)
    And normalv ← vector(0, 0, -1)
    And light ← point_light(point(0, 10, -10), color(1, 1, 1))
  When result ← lighting(m, light, position, eyev, normalv)
  Then result = color(0.7364, 0.7364, 0.7364): Passed [OK]
=> Validated Scenario

Scenario: Lighting with eye in the path of the reflection vector
  Given m ← material()
    And position ← point(0, 0, 0)
  Given eyev ← vector(0, -√2/2, -√2/2)
    And normalv ← vector(0, 0, -1)
    And light ← point_light(point(0, 10, -10), color(1, 1, 1))
  When result ← lighting(m, light, position, eyev, normalv)
  Then result = color(1.6364, 1.6364, 1.6364): Passed [OK]
=> Validated Scenario

Scenario: Lighting with the light behind the surface
  Given m ← material()
    And position ← point(0, 0, 0)
  Given eyev ← vector(0, 0, -1)
    And normalv ← vector(0, 0, -1)
    And light ← point_light(point(0, 0, 10), color(1, 1, 1))
  When result ← lighting(m, light, position, eyev, normalv)
  Then result = color(0.1, 0.1, 0.1): Passed [OK]
=> Validated Scenario

==> Finished Normal tests [OK]
##################

===> All test finished [OK]

Congratulations
